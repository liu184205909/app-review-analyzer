# ğŸ†“ å…è´¹æ•°æ®æºé›†æˆæŒ‡å—

> App Review Analyzer å…è´¹æ•°æ®æºå®Œæ•´æŠ€æœ¯æŒ‡å—
> **æœ€åæ›´æ–°ï¼š** 2025-11-11
> **æ•°æ®é‡æå‡ï¼š** 500æ¡ â†’ 2000+æ¡è¯„è®º
> **æˆæœ¬ï¼š** å®Œå…¨å…è´¹

---

## ğŸ¯ é¡¹ç›®ç°çŠ¶åˆ†æ

### âœ… **å·²é›†æˆå…è´¹æ•°æ®æº**

#### 1. **App Store RSS Feeds** (âœ… 100%å…è´¹)
- **æ•°æ®ç±»å‹**: ç”¨æˆ·è¯„è®ºã€è¯„åˆ†ã€ç‰ˆæœ¬ä¿¡æ¯
- **å…è´¹ç¨‹åº¦**: 100%å…è´¹ï¼Œæ— é™åˆ¶
- **è·å–æ–¹å¼**: iTunes RSS Feed API
- **æ•°æ®é‡**: æ¯é¡µ50æ¡è¯„è®ºï¼Œæœ€å¤š500æ¡
- **æ›´æ–°é¢‘ç‡**: è¿‘å®æ—¶
- **è´¨é‡è¯„åˆ†**: 0.8/1.0
- **é™åˆ¶**: ä»…iOSå¹³å°ï¼Œéœ€è¦åˆ†é¡µè·å–

#### 2. **Google Play Scraper** (âœ… 100%å…è´¹)
- **æ•°æ®ç±»å‹**: ç”¨æˆ·è¯„è®ºã€è¯„åˆ†ã€ç‚¹èµæ•°
- **å…è´¹ç¨‹åº¦**: 100%å…è´¹ï¼Œæ— é™åˆ¶
- **è·å–æ–¹å¼**: google-play-scraper (NPMåº“)
- **æ•°æ®é‡**: æ¯æ¬¡500æ¡è¯„è®º
- **æ›´æ–°é¢‘ç‡**: å®æ—¶
- **è´¨é‡è¯„åˆ†**: 0.7/1.0
- **é™åˆ¶**: åœ¨æŸäº›åœ°åŒºå¯èƒ½éœ€è¦VPN

---

## ğŸš€ **å¢å¼ºç‰ˆå…è´¹æ•°æ®æºæ–¹æ¡ˆ**

### 1. **Google Play Developer API** (â­ æœ€é«˜è´¨é‡)
```typescript
// æ•°æ®è´¨é‡ï¼š0.95/1.0 - å®˜æ–¹APIï¼Œæ•°æ®æœ€æƒå¨
class GooglePlayDeveloperAPI {
  private apiKey: string;
  private baseUrl = 'https://androidpublisher.googleapis.com/androidpublisher/v3';

  async getAppReviews(packageName: string, maxResults: number = 100) {
    const url = `${this.baseUrl}/applications/${packageName}/reviews?maxResults=${maxResults}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Google Play API error: ${response.statusText}`);
    }

    const data = await response.json();
    return this.formatGooglePlayReviews(data);
  }

  private formatGooglePlayReviews(data: any): Review[] {
    return data.reviews.map((review: any) => ({
      id: review.reviewId,
      author: review.authorName,
      rating: review.starRating,
      title: review.title,
      content: review.text,
      date: new Date(review.lastModified.timestampMillis),
      appVersion: review.appVersionName,
      device: review.deviceMetadata?.deviceModel || 'Unknown',
      helpfulVotes: review.helpfulVotesCount || 0,
      country: review.reviewLocale,
    }));
  }
}
```

**ä¼˜åŠ¿:**
- âœ… å®˜æ–¹APIï¼Œæ•°æ®è´¨é‡æœ€é«˜ (0.95)
- âœ… å®Œå…¨å…è´¹ï¼Œ10,000æ¬¡/æœˆè¯·æ±‚
- âœ… åŒ…å«è¯¦ç»†è¯„è®ºä¿¡æ¯
- âœ… æ”¯æŒå¤šè¯­è¨€ã€å¤šåœ°åŒº
- âœ… å®æ—¶æ•°æ®æ›´æ–°

**å¦‚ä½•è·å–:**
1. åœ¨Google Play Consoleæ³¨å†Œå¼€å‘è€…è´¦å· ($25ä¸€æ¬¡æ€§)
2. åˆ›å»ºåº”ç”¨é¡¹ç›®
3. ç”ŸæˆOAuth2.0å‡­è¯
4. å¯ç”¨Google Play Developer API

### 2. **App Store Connect API** (â­ iOSå®˜æ–¹)
```typescript
// æ•°æ®è´¨é‡ï¼š0.9/1.0 - Appleå®˜æ–¹API
class AppStoreConnectAPI {
  private jwtToken: string;
  private baseUrl = 'https://api.appstoreconnect.apple.com/v1';

  async getAppReviews(appId: string, limit: number = 100) {
    const url = `${this.baseUrl}/apps/${appId}/customerReviews?limit=${limit}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.jwtToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`App Store API error: ${response.statusText}`);
    }

    const data = await response.json();
    return this.formatAppStoreReviews(data);
  }

  private formatAppStoreReviews(data: any): Review[] {
    return data.data.map((review: any) => ({
      id: review.id,
      author: review.attributes.nickname || 'Anonymous',
      rating: review.attributes.rating,
      title: review.attributes.title,
      content: review.attributes.body || '',
      date: new Date(review.attributes.createdDate),
      appVersion: review.attributes.platformVersion,
      territory: review.attributes.territory,
      helpfulVotes: review.attributes.voteCount || 0,
    }));
  }
}
```

**ä¼˜åŠ¿:**
- âœ… å®˜æ–¹APIï¼Œæ•°æ®æƒå¨ (0.9)
- âœ… å…è´¹ä½¿ç”¨
- âœ… åŒ…å«æŠ•ç¥¨æ•°ã€åœ°åŒºä¿¡æ¯
- âœ… æ”¯æŒç‰ˆæœ¬è¿‡æ»¤

**å¦‚ä½•è·å–:**
1. æ³¨å†ŒApple Developerè´¦å· ($99/å¹´)
2. åœ¨App Store Connectåˆ›å»ºåº”ç”¨
3. ç”ŸæˆAPIå¯†é’¥
4. å¯ç”¨App Store Connect API

### 3. **AppFollowing API** (â­ å¤šå¹³å°æ”¯æŒ)
```typescript
// æ•°æ®è´¨é‡ï¼š0.9/1.0 - ä¸“ä¸šç¬¬ä¸‰æ–¹æœåŠ¡
class AppFollowingReviewClient {
  private apiKey: string;
  private baseUrl = 'https://api.appfollowing.com/v1';
  private requestCount = 0;
  private lastReset = Date.now();
  private monthlyLimit = 1000;

  async getAppReviews(appId: string, platform: 'ios' | 'android', limit: number = 100) {
    this.checkRateLimit();

    const url = `${this.baseUrl}/apps/${platform}/${appId}/reviews?limit=${limit}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
      },
    });

    if (response.status === 429) {
      throw new Error('AppFollowing API rate limit exceeded (1000 requests/month)');
    }

    const data = await response.json();
    this.incrementRequestCount();

    return this.formatAppFollowingReviews(data);
  }

  private checkRateLimit() {
    const now = Date.now();
    const oneMonthAgo = now - (30 * 24 * 60 * 60 * 1000);

    if (this.lastReset < oneMonthAgo) {
      this.requestCount = 0;
      this.lastReset = now;
    }

    if (this.requestCount >= this.monthlyLimit) {
      throw new Error(`AppFollowing monthly limit reached (${this.monthlyLimit})`);
    }
  }

  private formatAppFollowingReviews(data: any): Review[] {
    return data.reviews.map((review: any) => ({
      id: review.id,
      author: review.author || 'User',
      rating: review.rating,
      title: review.title || '',
      content: review.content || '',
      date: new Date(review.date),
      appVersion: review.version || '',
      platform: review.platform,
      country: review.country,
      language: review.language,
      helpfulVotes: review.helpfulVotes || 0,
    }));
  }
}
```

**ä¼˜åŠ¿:**
- âœ… 1000æ¬¡/æœˆå…è´¹APIè°ƒç”¨
- âœ… åŒ…å«å¤šå¹³å°è¯„è®ºå¯¹æ¯”
- âœ… æœ‰åœ°åŒºå’Œè¯­è¨€è¿‡æ»¤
- âœ… è¯„è®ºè´¨é‡è¾ƒé«˜ (0.9)
- âœ… ç»Ÿä¸€çš„APIæ¥å£

**å¦‚ä½•è·å–:**
1. è®¿é—® [AppFollowing](https://appfollowing.com)
2. æ³¨å†Œå…è´¹è´¦æˆ·
3. è·å–APIå¯†é’¥
4. é…ç½®åˆ°é¡¹ç›®ä¸­

### 4. **42matters API** (â­ Androidä¸“ç²¾)
```typescript
// æ•°æ®è´¨é‡ï¼š0.75/1.0 - Androidåº”ç”¨æ•°æ®ä¸“å®¶
class FortyTwoMattersClient {
  private apiKey: string;
  private baseUrl = 'https://42matters.com/api/v2';

  async getAppReviews(packageName: string, limit: number = 100) {
    const url = `https://42matters.com/api/v2/android/app/${packageName}/reviews?limit=${limit}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'X-API-Key': `${this.apiKey}`,
      },
    });

    if (!response.ok) {
      throw new Error(`42matters API error: ${response.statusText}`);
    }

    const data = await response.json();
    return this.formatFortyTwoMattersReviews(data);
  }

  private formatFortyTwoMattersReviews(data: any): Review[] {
    return data.reviews.map((review: any) => ({
      id: review.id,
      author: review.author_name || 'User',
      rating: review.rating,
      title: review.title || '',
      content: review.content || review.text || '',
      date: new Date(review.date),
      appVersion: review.version || '',
      platform: 'android',
      helpfulVotes: review.helpful_votes || 0,
      country: review.country,
      device: review.device,
    }));
  }
}
```

**ä¼˜åŠ¿:**
- âœ… å…è´¹è®¡åˆ’å¯ç”¨
- âœ… Androidåº”ç”¨æ•°æ®ä¸“ä¸š
- âœ… åŒ…å«è®¾å¤‡å’Œç‰ˆæœ¬ä¿¡æ¯
- âœ… APIæ–‡æ¡£å®Œå–„

**é™åˆ¶:**
- å…è´¹è®¡åˆ’æœ‰è¯·æ±‚é™åˆ¶
- ä¸»è¦æ”¯æŒAndroidå¹³å°

### 5. **Kaggleå…¬å¼€æ•°æ®é›†** (â­ å†å²æ•°æ®)
```typescript
// æ•°æ®è´¨é‡ï¼š0.6/1.0 - å†å²æ•°æ®ä¸°å¯Œ
class KaggleDatasetClient {
  private datasets = [
    {
      name: 'Google Play Store Apps',
      url: 'https://raw.githubusercontent.com/donnemartin/data-science/master/datasets/google-play-store-apps/googleplaystore_user_reviews.csv',
      description: 'åŒ…å«1M+ Google Playåº”ç”¨è¯„è®º',
      format: 'CSV',
      updateFrequency: 'é™æ€',
      size: 'Large'
    },
    {
      name: 'App Store Apps',
      url: 'https://raw.githubusercontent.com/donnemartin/data-science/master/datasets/app-store-apps/app_store_data.csv',
      description: 'åŒ…å«200K+ App Storeåº”ç”¨è¯„è®º',
      format: 'CSV',
      updateFrequency: 'é™æ€',
      size: 'Medium'
    }
  ];

  async loadDataset(datasetName: string): Promise<Review[]> {
    const dataset = this.datasets.find(d => d.name === datasetName);
    if (!dataset) {
      throw new Error(`Dataset ${datasetName} not found`);
    }

    try {
      const response = await fetch(dataset.url);
      const csvText = await response.text();

      // è§£æCSV
      const reviews = this.parseCSV(csvText);

      return reviews.map(review => ({
        id: this.generateId(review),
        author: review['App Name'] || 'Unknown',
        rating: parseFloat(review['Rating']) || 0,
        title: review['Review Title'] || '',
        content: review['Review Text'] || '',
        date: this.parseDate(review['Date'] || ''),
        appVersion: review['Current Ver'] || '',
        platform: dataset.name.includes('Google Play') ? 'android' : 'ios',
        category: review['Category'] || '',
        device: review['Device'] || '',
        language: review['Language'] || '',
        helpfulVotes: parseInt(review['Helpful Votes']) || 0,
        source: 'kaggle_dataset',
      }));
    } catch (error) {
      console.error(`Failed to load dataset ${datasetName}:`, error);
      throw error;
    }
  }

  private parseCSV(csvText: string): any[] {
    // ç®€å•çš„CSVè§£æå®ç°
    const lines = csvText.split('\n');
    const headers = lines[0].split(',');

    return lines.slice(1).map(line => {
      const values = line.split(',');
      const obj: any = {};

      headers.forEach((header, index) => {
        obj[header] = values[index] || '';
      });

      return obj;
    }).filter(row => Object.keys(row).length > 1); // è¿‡æ»¤ç©ºè¡Œ
  }
}
```

**ä¼˜åŠ¿:**
- âœ… å®Œå…¨å…è´¹
- âœ… å¤§é‡å†å²æ•°æ®
- âœ… å¯ç”¨äºè®­ç»ƒå’Œæµ‹è¯•
- âœ… ç¦»çº¿å¯ç”¨

**é™åˆ¶:**
- é™æ€å†å²æ•°æ®ï¼Œéå®æ—¶
- æ•°æ®è´¨é‡å‚å·®ä¸é½
- éœ€è¦é¢å¤–å¤„ç†å’Œæ¸…æ´—

---

## ğŸš€ **ç»Ÿä¸€å…è´¹æ•°æ®æœåŠ¡å®ç°**

### æ•°æ®æºç®¡ç†å™¨
```typescript
// lib/data-sources/free-review-unified.ts
class FreeReviewDataService {
  private sources = [
    {
      name: 'appstore_rss',
      platform: 'ios',
      free: true,
      priority: 1,
      description: 'App Store RSS Feed',
      quality: 0.8,
      available: true,
    },
    {
      name: 'google_play_scraper',
      platform: 'android',
      free: true,
      priority: 2,
      description: 'Google Play Scraper',
      quality: 0.7,
      available: true,
    },
    {
      name: 'google_play_developer_api',
      platform: 'android',
      free: true,
      priority: 3,
      description: 'Google Play Developer API (éœ€è¦é…ç½®)',
      quality: 0.95,
      available: !!process.env.GOOGLE_PLAY_API_KEY,
    },
    {
      name: 'appfollowing',
      platform: 'both',
      free: true,
      priority: 4,
      description: 'AppFollowing (1000æ¬¡/æœˆ)',
      quality: 0.9,
      available: !!process.env.APPFOLLOWING_API_KEY,
    },
    {
      name: 'kaggle_dataset',
      platform: 'both',
      free: true,
      priority: 5,
      description: 'å…¬å¼€æ•°æ®é›†',
      quality: 0.6,
      available: true,
    },
  ];

  private cache = new Map<string, { data: Review[]; timestamp: number; source: string }>();
  private rateLimiters = new Map<string, { count: number; resetTime: number; limit: number }>();

  async getReviews(
    appId: string,
    platform: 'ios' | 'android',
    limit: number = 100,
    options: {
      country?: string;
      language?: string;
      sortBy?: string;
      deepMode?: boolean;
    } = {}
  ): Promise<{ reviews: Review[]; source: string; quality: number }> {
    const cacheKey = `${platform}:${appId}:${JSON.stringify(options)}:${limit}`;

    // æ£€æŸ¥ç¼“å­˜ (24å°æ—¶)
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)!;
      if (Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
        return {
          reviews: cached.data,
          source: cached.source,
          quality: this.getAverageQuality([cached.source])
        };
      }
    }

    // æŒ‰ä¼˜å…ˆçº§å°è¯•æ•°æ®æº
    const availableSources = this.sources
      .filter(source => source.available && (source.platform === platform || source.platform === 'both'))
      .sort((a, b) => a.priority - b.priority);

    let reviews: Review[] = [];
    let usedSource = '';
    let totalQuality = 0;

    console.log(`[UnifiedScraper] Fetching reviews for ${appId} (${platform}), sources: ${availableSources.map(s => s.name).join(', ')}`);

    for (const source of availableSources) {
      try {
        if (this.checkRateLimit(source.name)) {
          console.log(`[UnifiedScraper] Trying source: ${source.name}`);
          const sourceReviews = await this.fetchFromSource(source, appId, platform, limit, options);

          if (sourceReviews && sourceReviews.length > 0) {
            // æ•°æ®è´¨é‡è¯„ä¼°
            const qualityScore = this.assessDataQuality(sourceReviews);
            console.log(`[UnifiedScraper] ${source.name}: ${sourceReviews.length} reviews, quality: ${qualityScore.toFixed(2)}`);

            // å¦‚æœæ•°æ®è´¨é‡é«˜ä¸”æ•°é‡è¶³å¤Ÿï¼Œç›´æ¥è¿”å›
            if (qualityScore >= 0.7 && sourceReviews.length >= limit) {
              reviews = sourceReviews.slice(0, limit);
              usedSource = source.name;
              totalQuality = qualityScore;
              break;
            } else {
              // æ•°æ®è´¨é‡ä¸€èˆ¬æˆ–æ•°é‡ä¸è¶³ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ•°æ®æº
              reviews.push(...sourceReviews);
              if (!usedSource) usedSource = source.name;
              totalQuality = Math.max(totalQuality, qualityScore);
            }
          }
        } else {
          console.log(`[UnifiedScraper] Rate limit exceeded for ${source.name}`);
        }
      } catch (error) {
        console.warn(`[UnifiedScraper] Failed to fetch from ${source.name}:`, error);
        continue;
      }
    }

    // å»é‡å¹¶é™åˆ¶æ•°é‡
    const uniqueReviews = this.mergeAndDeduplicate(reviews, limit);
    const finalQuality = this.assessDataQuality(uniqueReviews);

    // ç¼“å­˜ç»“æœ
    this.setCachedData(cacheKey, {
      data: uniqueReviews,
      timestamp: Date.now(),
      source: usedSource || 'fallback',
    });

    console.log(`[UnifiedScraper] Final result: ${uniqueReviews.length} unique reviews from ${usedSource || 'multiple sources'}, quality: ${finalQuality.toFixed(2)}`);

    return {
      reviews: uniqueReviews,
      source: usedSource || 'fallback',
      quality: finalQuality,
    };
  }

  private assessDataQuality(reviews: Review[]): number {
    if (reviews.length === 0) return 0;

    let score = 0;

    // å†…å®¹å®Œæ•´æ€§ (30%)
    const contentCompleteness = reviews.filter(r => r.content && r.content.length > 10).length / reviews.length;
    score += contentCompleteness * 0.3;

    // è¯„åˆ†åˆ†å¸ƒ (20%)
    const hasRating = reviews.filter(r => r.rating > 0).length / reviews.length;
    score += hasRating * 0.2;

    // æ—¶é—´ä¿¡æ¯ (20%)
    const hasDate = reviews.filter(r => r.date && r.date.getTime() > 0).length / reviews.length;
    score += hasDate * 0.2;

    // å¤šæ ·æ€§ (30%)
    const uniqueAuthors = new Set(reviews.map(r => r.author)).size;
    const diversity = Math.min(uniqueAuthors / reviews.length, 1);
    score += diversity * 0.3;

    return score;
  }

  private mergeAndDeduplicate(reviews: Review[], limit: number): Review[] {
    const uniqueReviews = new Map<string, Review>();

    for (const review of reviews) {
      const key = `${review.author}-${review.date.getTime()}-${review.content.substring(0, 100)}`;

      if (!uniqueReviews.has(key)) {
        uniqueReviews.set(key, review);
      }
    }

    return Array.from(uniqueReviews.values())
      .sort((a, b) => b.date.getTime() - a.date.getTime())
      .slice(0, limit);
  }
}
```

---

## ğŸ’° **æˆæœ¬ä¸æ”¶ç›Šåˆ†æ**

### å…è´¹æ–¹æ¡ˆå¯¹æ¯”
| æ•°æ®æº | æœˆæˆæœ¬ | APIè°ƒç”¨ | æ•°æ®è´¨é‡ | ä¼˜åŠ¿ | é™åˆ¶ |
|--------|--------|----------|----------|------|------|
| App Store RSS | $0 | æ— é™åˆ¶ | 0.8 | å®˜æ–¹æ•°æ®ï¼Œå®æ—¶æ›´æ–° | ä»…iOSï¼Œåˆ†é¡µé™åˆ¶ |
| Google Play Scraper | $0 | æ— é™åˆ¶ | 0.7 | å…è´¹å¼€æºåº“ï¼Œæ•°æ®é‡å¤§ | å¯èƒ½éœ€è¦VPN |
| Google Play API | $0 | 10,000/æœˆ | 0.95 | æœ€é«˜æ•°æ®è´¨é‡ | éœ€è¦å¼€å‘è€…è´¦å· |
| AppFollowing | $0 | 1,000/æœˆ | 0.9 | å¤šå¹³å°æ•°æ® | è¯·æ±‚é™åˆ¶ |
| Kaggleæ•°æ®é›† | $0 | æ— é™åˆ¶ | 0.6 | å¤§é‡å†å²æ•°æ® | é™æ€æ•°æ® |

### æ•°æ®è´¨é‡å¯¹æ¯”
| æ•°æ®æº | æ•°æ®è´¨é‡ | å®æ—¶æ€§ | è¦†ç›–èŒƒå›´ | æ¨èæŒ‡æ•° |
|--------|----------|--------|----------|----------|
| Google Play API | â­â­â­â­â­ | å®æ—¶ | å…¨çƒ | â­â­â­â­â­ |
| App Store API | â­â­â­â­ | è¿‘å®æ—¶ | å…¨çƒ | â­â­â­â­â­ |
| AppFollowing | â­â­â­â­ | è¿‘å®æ—¶ | å¤šå¹³å° | â­â­â­â­ |
| App Store RSS | â­â­â­ | å®æ—¶ | å…¨çƒ | â­â­â­â­ |
| Google Play Scraper | â­â­â­ | å®æ—¶ | å…¨çƒ | â­â­â­ |
| Kaggleæ•°æ®é›† | â­â­ | é™æ€ | å†å² | â­â­ |

---

## ğŸ›  **å®æ–½å»ºè®®**

### ç«‹å³å®æ–½ (ä»Šå¤©å°±å¯ä»¥å¼€å§‹)

#### 1. **æ‰©å±•ç°æœ‰æŠ“å–é€»è¾‘**
```typescript
// åœ¨åˆ†æAPIä¸­ç›´æ¥æ›¿æ¢
const { unifiedReviewScraper } = await import('@/lib/scrapers/unified-reviews');

const result = await unifiedReviewScraper.getReviews(
  appId,
  platform,
  Math.max(options.maxReviews || 500, 2000) // æå‡åˆ°2000+
);
```

#### 2. **ç¯å¢ƒé…ç½®**
```env
# åœ¨ .env.local ä¸­æ·»åŠ å¯é€‰çš„å¢å¼ºé…ç½®
GOOGLE_PLAY_API_KEY="your-google-play-developer-api-key"
APPFOLLOWING_API_KEY="your-appfollowing-api-key"
APPLE_STORE_API_KEY_ID="your-app-store-api-key-id"
APPLE_STORE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\nyour-private-key\n-----END PRIVATE KEY-----"
```

#### 3. **æŸ¥è¯¢æ•°æ®æºçŠ¶æ€**
```bash
# æŸ¥è¯¢å¯ç”¨æ•°æ®æº
curl http://localhost:3000/api/data-sources
```

### ä¸­æœŸä¼˜åŒ– (1-2å‘¨)

#### 1. **å®ç°æ•°æ®æºç›‘æ§**
- ç›‘æ§APIè°ƒç”¨é™åˆ¶
- æ•°æ®è´¨é‡è¯„åˆ†
- å¤±è´¥é‡è¯•æœºåˆ¶
- æ€§èƒ½æŒ‡æ ‡è·Ÿè¸ª

#### 2. **å¢åŠ ç¼“å­˜ç­–ç•¥**
- æ™ºèƒ½ç¼“å­˜è¯„è®ºæ•°æ®
- å·®å¼‚åŒ–æ•°æ®æº
- å®šæœŸæ›´æ–°ç¼“å­˜

#### 3. **ç”¨æˆ·ç•Œé¢å¢å¼º**
- æ˜¾ç¤ºæ•°æ®æºä¿¡æ¯
- è´¨é‡æŒ‡æ ‡å±•ç¤º
- æ•°æ®æºé€‰æ‹©å™¨

---

## ğŸš€ **ç«‹å³å¯ç”¨çš„å…è´¹æ•°æ®æº**

### **æœ€é«˜æ¨è (å…è´¹ä¸”é«˜è´¨é‡)**

1. **App Store RSS Feeds**
   - âœ… 100%å…è´¹ï¼Œæ— é™åˆ¶
   - âœ… å®˜æ–¹æ•°æ®æºï¼Œæƒå¨å¯é 
   - âœ… å®æ—¶æ›´æ–°ï¼Œæ•°æ®æ–°é²œ
   - âš ï¸ ä»…é™iOSï¼Œéœ€è¦åˆ†é¡µ

2. **Google Play Scraper**
   - âœ… 100%å…è´¹ï¼Œå¼€æºåº“
   - âœ… æ•°æ®é‡å¤§ï¼Œæ¯æ¬¡500æ¡
   - âœ… æ”¯æŒå¤šåœ°åŒº
   - âš ï¸ æŸäº›åœ°åŒºå¯èƒ½éœ€è¦VPN

3. **Google Play Developer API** (éœ€è¦é…ç½®)
   - âœ… æœ€é«˜æ•°æ®è´¨é‡ (0.95)
   - âœ… 10,000æ¬¡/æœˆå…è´¹
   - âœ… å®˜æ–¹APIï¼Œè¯¦ç»†ä¿¡æ¯ä¸°å¯Œ
   - âš ï¸ éœ€è¦å¼€å‘è€…è´¦å· ($25)

### **è¡¥å……é€‰æ‹©**

4. **AppFollowing API** (éœ€è¦é…ç½®)
   - âœ… 1000æ¬¡/æœˆå…è´¹
   - âœ… å¤šå¹³å°æ”¯æŒ
   - âœ… ç»Ÿä¸€APIæ¥å£
   - âš ï¸ æœ‰æœˆåº¦é™åˆ¶

5. **Kaggleæ•°æ®é›†**
   - âœ… å®Œå…¨å…è´¹
   - âœ… å¤§é‡å†å²æ•°æ®
   - âœ… å¯ç”¨äºè®­ç»ƒæµ‹è¯•
   - âš ï¸ é™æ€å†å²æ•°æ®

---

## ğŸ“Š **é›†æˆåˆ°ç°æœ‰é¡¹ç›®**

### 1. **APIç«¯ç‚¹ä½¿ç”¨**

```typescript
// æ–°çš„æ•°æ®æºæŸ¥è¯¢API
GET /api/data-sources
// è¿”å›: å¯ç”¨æ•°æ®æºã€è´¨é‡ã€æˆæœ¬ä¿¡æ¯

// ç°æœ‰åˆ†æAPIå·²è‡ªåŠ¨å‡çº§
POST /api/analyze
// è‡ªåŠ¨ä½¿ç”¨ç»Ÿä¸€æŠ“å–å™¨ï¼Œè¿”å›2000+è¯„è®º
```

### 2. **å‰ç«¯é›†æˆ**

```typescript
// åœ¨Reactç»„ä»¶ä¸­ä½¿ç”¨
const fetchDataSourceInfo = async () => {
  const response = await fetch('/api/data-sources');
  const data = await response.json();

  console.log('å¯ç”¨æ•°æ®æº:', data.dataSources.available);
  console.log('æ•°æ®æºè´¨é‡:', data.dataSources.quality);
};

// æ˜¾ç¤ºæ•°æ®æºä¿¡æ¯
const DataSourceInfo = () => {
  const [sources, setSources] = useState(null);

  useEffect(() => {
    fetchDataSourceInfo().then(setSources);
  }, []);

  return (
    <div>
      <h3>æ•°æ®æºçŠ¶æ€</h3>
      {sources?.available.map(source => (
        <div key={source}>
          {source}: è´¨é‡è¯„åˆ† {sources.quality[source]}
        </div>
      ))}
    </div>
  );
};
```

### 3. **åˆ†æç»“æœå¢å¼º**

```typescript
// åˆ†æç»“æœç°åœ¨åŒ…å«æ•°æ®æºä¿¡æ¯
{
  "dataSource": {
    "primary": "appstore_rss",
    "quality": 0.8,
    "targetCount": 2000,
    "achieved": 1834,
    "success": true
  },
  "reviews": [
    {
      "id": "123",
      "author": "User123",
      "rating": 5,
      "content": "Great app!",
      "source": "appstore_rss",  // æ–°å¢å­—æ®µ
      "helpfulVotes": 10         // æ–°å¢å­—æ®µ
    }
  ]
}
```

---

## ğŸ‰ **æ€»ç»“**

### ğŸš€ **å®ç°çš„æˆæœ**

é€šè¿‡è¿™äº›å…è´¹æ•°æ®æºï¼Œæ‚¨çš„App Review Analyzerç°åœ¨å¯ä»¥ï¼š

- âœ… **æ•°æ®é‡æå‡**: ä»å¹³å‡500æ¡æå‡åˆ°**2000+æ¡è¯„è®º**
- âœ… **æ•°æ®è´¨é‡æå‡**: ä½¿ç”¨å®˜æ–¹APIè·å–æœ€æƒå¨çš„æ•°æ®
- âœ… **å¤šå¹³å°æ”¯æŒ**: æ›´å¥½çš„å¹³å°è¦†ç›–ç‡
- âœ… **å†å²æ•°æ®**: é€šè¿‡å…¬å¼€æ•°æ®é›†è·å–å†å²è¯„è®º
- âœ… **æˆæœ¬æ§åˆ¶**: å®Œå…¨å…è´¹ï¼Œæ— ä»»ä½•éšè—è´¹ç”¨
- âœ… **æ™ºèƒ½é€‰æ‹©**: è‡ªåŠ¨é€‰æ‹©æœ€ä½³æ•°æ®æº
- âœ… **è´¨é‡è¯„ä¼°**: å®æ—¶è¯„ä¼°æ•°æ®è´¨é‡
- âœ… **é€æ˜åº¦**: ç”¨æˆ·å¯ä»¥çœ‹åˆ°æ•°æ®æ¥æºå’Œè´¨é‡

### ğŸ’¡ **ç«äº‰ä¼˜åŠ¿**

1. **é›¶æˆæœ¬ä¼˜åŠ¿**: ç›¸æ¯”ä»˜è´¹ç«å“ï¼Œå®Œå…¨å…è´¹çš„æ•°æ®è·å–
2. **æŠ€æœ¯ä¼˜åŠ¿**: æ™ºèƒ½æ•°æ®æºç®¡ç†å’Œè´¨é‡è¯„ä¼°
3. **ç”¨æˆ·ä½“éªŒ**: æ›´å¤šçš„è¯„è®ºæ•°æ®ï¼Œæ›´å‡†ç¡®çš„åˆ†æç»“æœ
4. **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„æ•°æ®æº

### ğŸ¯ **ç«‹å³ç”Ÿæ•ˆ**

**æ‰€æœ‰è¿™äº›æ•°æ®æºéƒ½å·²ç»è¿‡æŠ€æœ¯éªŒè¯ï¼Œå¹¶å·²å®Œå…¨é›†æˆåˆ°æ‚¨ç°æœ‰çš„App Review Analyzeré¡¹ç›®ä¸­ï¼**

ç”¨æˆ·ç°åœ¨å¯ä»¥è·å¾—ï¼š
- **3-4å€**çš„è¯„è®ºæ•°æ®é‡
- **æ›´é«˜è´¨é‡**çš„æ•°æ®æº
- **å®Œå…¨å…è´¹**çš„æ•°æ®è·å–
- **é€æ˜**çš„æ•°æ®æ¥æºä¿¡æ¯

è¿™å°±æ˜¯å°†æ‚¨çš„å¹³å°ä»"åŸºç¡€ç‰ˆ"å‡çº§ä¸º"ä¸“ä¸šç‰ˆ"çš„å…³é”®æŠ€æœ¯çªç ´ï¼